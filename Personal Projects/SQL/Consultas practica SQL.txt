Pregunta 1:

-- ¿Qué géneros son más prevalentes en la base de datos NetflixDB? 
-- Genera una lista de los distintos géneros y la cantidad de series por cada uno.

SELECT genero, COUNT(*) AS cantidad_de_series
FROM Series
GROUP BY genero
ORDER BY cantidad_de_series DESC;

-- Esta consulta SQL nos permite ver cuántas series hay en cada género dentro de la base de datos NetflixDB. 
-- Agrupando las series por su género y contándolas, podemos identificar cuáles géneros son más prevalentes.

-- ¿Cuáles son las tres series con mayor rating IMDB y cuántos episodios tienen? 
-- Considera usar un JOIN para combinar la información de las tablas de series y episodios.

SELECT Series.titulo, COUNT(Episodios.episodio_id) AS numero_de_episodios, AVG(episodios.rating_imdb) AS promedio_imdb
FROM Series
INNER JOIN Episodios ON Series.serie_id = Episodios.serie_id
GROUP BY Series.serie_id
ORDER BY promedio_imdb DESC
LIMIT 3;

-- Con esta consulta, identificamos las tres series con el mayor rating IMDB 
-- en la base de datos y contamos cuántos episodios tiene cada una de ellas, combinando información de las tablas Series y Episodios.

-- ¿Cuál es la duración total de todos los episodios para la serie "Stranger Things"? 
-- Este análisis te permitirá entender el compromiso temporal necesario para ver una serie completa.

SELECT SUM(Episodios.duracion) AS duracion_total
FROM Series
INNER JOIN Episodios ON Series.serie_id = Episodios.serie_id
WHERE Series.titulo = 'Stranger Things';


Pregunta 2:

-- Realiza subconsulta para identificar los 3 generos mas populares
-- Ahora para cada genero identificar titulo, año de lanzamiento y rating promedio
SELECT 
    Series.titulo AS 'Título de la Serie', 
    Series.año_lanzamiento AS 'Año de Lanzamiento', 
    Series.genero AS 'Género', 
    AVG(Episodios.rating_imdb) AS 'Rating Promedio IMDb'
FROM 
    Series
JOIN 
    Episodios ON Series.serie_id = Episodios.serie_id
WHERE 
    Series.genero IN (SELECT genero FROM (
					  SELECT genero, COUNT(*) AS cantidad_de_series
					  FROM Series 
					  GROUP BY genero 
                      ORDER BY cantidad_de_series DESC
                      LIMIT 3) AS top3)
GROUP BY 
    Series.serie_id
ORDER BY 
    'Rating Promedio IMDb' DESC;


Pregunta 3:

-- Identificar las series mas exitosas por cantidad de episodios y rating
WITH EpisodiosRecientes AS (
  SELECT 
    serie_id,
    COUNT(episodio_id) AS num_episodios
  FROM Episodios
  GROUP BY serie_id
),
Calificaciones AS (
  SELECT 
    serie_id,
    AVG(rating_imdb) AS promedio_imdb
  FROM Episodios
  GROUP BY serie_id
)

SELECT 
  s.titulo,
  er.num_episodios,
  c.promedio_imdb
FROM Series s
JOIN EpisodiosRecientes er ON s.serie_id = er.serie_id
JOIN Calificaciones c ON s.serie_id = c.serie_id
ORDER BY c.promedio_imdb DESC, er.num_episodios DESC;


Pregunta 4:

DELIMITER //

CREATE PROCEDURE AsignarHorasAProyecto(IN proyectoId INT, IN empleadoId INT, IN horasAsignadas INT)
BEGIN
    DECLARE horasTotales INT DEFAULT 0;
    DECLARE horasMaximas INT DEFAULT 100;
    
    -- Iniciar una transacción
    START TRANSACTION;
    
    -- Establecer un punto de guardado
    SAVEPOINT PreValidacion;
    
    -- Calcular el total actual de horas asignadas al proyecto
    SELECT SUM(horas_asignadas) INTO horasTotales 
    FROM AsignacionesDeProyectos 
    WHERE proyecto_id = proyectoId;
    
    -- Asumiendo que SUM() puede devolver NULL si no hay filas, lo convertimos a 0
    SET horasTotales = IFNULL(horasTotales, 0) + horasAsignadas;
    
    -- Verificar si el total excede las horas máximas permitidas
    IF horasTotales > horasMaximas THEN
        -- Revertir a SAVEPOINT si se excede el total de horas
        ROLLBACK TO PreValidacion;
        -- Aunque el ROLLBACK TO SAVEPOINT mantiene la transacción activa, decidimos terminar la operación con un mensaje de error.
        SELECT 'Error: La asignación excede el total de horas permitidas para el proyecto.' AS mensaje;
    ELSE
        -- Insertar la nueva asignación si el total está dentro del límite
        INSERT INTO AsignacionesDeProyectos (proyecto_id, empleado_id, horas_asignadas) 
        VALUES (proyectoId, empleadoId, horasAsignadas);
        
        -- Confirmar la transacción si todas las operaciones fueron exitosas
        COMMIT;
    END IF;
END //

DELIMITER ;

CALL AsignarHorasProyecto(1,1,5)

Pregunta 5:

-- Crear SP llamado agregardepartamento que admita dos parametros de entrada(nombre y ubicacion)
DELIMITER //

CREATE PROCEDURE AgregarDepartamento(IN _nombre VARCHAR(255), IN _ubicacion VARCHAR(255))
BEGIN
	INSERT INTO Departamentos (nombre, ubicacion) VALUES (_nombre, _ubicacion);
END //

DELIMITER ;

Pregunta 6:

-- Cree una vista que muestre nombre y apellido del empleado y proyecto al que esta asignado
CREATE VIEW VistaEmpleadosProyectos AS
SELECT E.nombre AS NombreEmpleado, E.apellido AS ApellidoEmpleado, P.nombre AS NombreProyecto
FROM Empleados E
JOIN AsignacionesDeProyectos A ON E.empleado_id = A.empleado_id
JOIN Proyectos P ON A.proyecto_id = P.proyecto_id;


Pregunta 7:

-- Ejercicio 1
SELECT 
    E.nombre AS 'Nombre Empleado', 
    E.apellido AS 'Apellido Empleado', 
    P.nombre AS 'Nombre Proyecto', 
    A.horas_asignadas AS 'Horas Asignadas'
FROM 
    Empleados E
JOIN 
    AsignacionesDeProyectos A ON E.empleado_id = A.empleado_id
JOIN 
    Proyectos P ON A.proyecto_id = P.proyecto_id
ORDER BY 
    E.nombre, E.apellido, A.horas_asignadas DESC;


Pregunta 8:

-- Ejercicio 2
SELECT 
    D.nombre AS 'Nombre Departamento',
    SUM(AP.horas_asignadas) AS 'Total Horas Asignadas'
FROM 
    Departamentos D
JOIN 
    Empleados E ON D.depto_id = E.depto_id
JOIN 
    AsignacionesDeProyectos AP ON E.empleado_id = AP.empleado_id
GROUP BY 
    D.nombre
ORDER BY 
    SUM(AP.horas_asignadas) DESC;


Pregunta 9:

-- Ejercicio 3
SELECT 
    E.nombre AS 'Nombre',
    E.apellido AS 'Apellido',
    SUM(AP.horas_asignadas) AS 'Total Horas Trabajadas',
    RANK() OVER (PARTITION BY E.depto_id ORDER BY SUM(AP.horas_asignadas) DESC) AS 'Ranking Departamental'
FROM 
    Empleados E
JOIN 
    AsignacionesDeProyectos AP ON E.empleado_id = AP.empleado_id
GROUP BY 
    E.empleado_id, E.nombre, E.apellido, E.depto_id
ORDER BY 
    E.depto_id, 'Ranking Departamental';

Lista de empleados con su nombre, apellido, el total de horas trabajadas y su ranking dentro de su departamento
por horas trabajadas